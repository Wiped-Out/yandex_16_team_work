[uwsgi]
# путь до wsgi-файла, сгенерированного Django
wsgi-file = config/wsgi.py

strict = true  # предотвращает запуск сервера, если он неправильно настроен
socket = :8000  # порт, на котором принимаются запросы пользователей
protocol = http

# запустить мастер-процесс для управления дочерними процессами
master = true

# завершить все дочерние процессы
no-orphans = true

# остановить сервер при получении сигнала SIGTERM
die-on-term = true

# ленивая инициализация приложения
# это позволяет запускать сервер быстрее
# первый запрос, полученный процессом, будет работать медленно
#так как приложение будет инициализироваться.
lazy-apps = true

# количество процессов, создаваемое мастер-процессом
# рекомендуется поставить число, не превышающее количество доступных ядер процессора
processes = 4

# количество потоков, используемых каждым процессом
# каждый запрос от пользователя обрабатывается в отдельном потоке
# с помощью этих настроек можно установить максимальное количество обрабатываемых запросов
# в этой конфигурации сервер сможет обработать 32 запроса одновременно
# это число получили, умножив количество процессов на количество потоков
threads = 8

# по умолчанию uWSGI не инициирует GIL, поэтому потоки не будут работать внутри приложения
enable-threads = true

# через какое количество запросов перезапустить воркер
# это полезно для профилактики утечек памяти
max-requests = 500

# принудительно перезагрузить воркер, если он ревысит порог по потребляемой памяти
reload-on-rss = 1024

# как долго ждать обработки текущих запросов воркером до принудительной перезагрузки
worker-reload-mercy = 60

# через сколько секунд принудительно завершить запрос от пользователя
harakiri = 60
harakiri-verbose = true

# очистить временные файлы и UNIX-сокеты, используемые сервером
vacuum = true

# прежде чем передать запрос приложению
# uWSGI считает в памяти его содержимое
post-buffering = 1048576

# размер буфера для чтения HTTP-заголовков
buffer-size = 65535